# I/O 寻址方式总结

CPU 与设备控制器（Device Controller）交互主要通过读写控制器内的寄存器来实现。根据寄存器的地址映射方式，分为两种主要模式。
Memory overhead is not affected by either method of I/O.

## 1. Port-Mapped I/O (端口映射 I/O)

在传统的 PC 架构（如 Intel x86）中常见。

* **独立地址空间**：I/O 设备拥有自己独立的地址空间，与主内存（DRAM）的地址空间完全分开。
* **专用指令**：CPU 必须使用专门的 I/O 指令来访问这些地址。
    * **指令示例**：Intel 汇编中的 `in` 和 `out` 指令。
    * *例如*：`out 0x21, AL` (将寄存器 AL 的值写入 I/O 端口 0x21)。
* **特点**：
    * 地址空间通常较小（例如 64KB）。
    * 硬件上需要额外的控制线来区分当前是“内存访问”还是“I/O 访问”。

## 2. Memory-Mapped I/O (内存映射 I/O)

现代嵌入式系统（如 ARM）和高性能设备（如显卡）的主流方式。

* **统一地址空间**：I/O 设备的寄存器和内存被映射到同一个物理地址空间中。I/O 设备看起来就像是一块特定的内存区域。
    * *例如*：物理地址 `0x8000F000` 可能对应显卡的显示内存，而不是 DRAM。
* **通用指令**：CPU 使用标准的内存读写指令（Load/Store）来访问设备。
    * **指令示例**：`MOV`、`LOAD`、`STORE`。
    * 不需要专门的 I/O 指令。
* **特点**：
    * **简化 CPU 设计**：不需要在指令集中增加专门的 I/O 指令。
    * **灵活性**：可以使用所有针对内存操作的指令（如位运算、自增等）直接操作设备寄存器。
    * **保护机制**：可以利用现有的虚拟内存保护机制（页表）来保护 I/O 设备，防止用户进程非法访问。
* **案例 (Display Controller)**：
    * 显卡的控制寄存器和显示内存（Frame Buffer）都映射到物理地址空间。
    * 写入特定的内存地址（如 `0x8000F000`）就可以直接改变屏幕上显示的图像。

## 3. 核心对比表

| 特性 | Port-Mapped I/O | Memory-Mapped I/O |
| :--- | :--- | :--- |
| **地址空间** | 独立的 I/O 地址空间 | 与主内存共享物理地址空间 |
| **CPU 指令** | 专用指令 (`in`, `out`) | 通用内存指令 (`load`, `store`) |
| **CPU 设计** | 需支持专用 I/O 逻辑 | 设计更简单，逻辑复用 |
| **地址范围** | 通常较小 (e.g., 16-bit) | 很大 (32-bit / 64-bit) |